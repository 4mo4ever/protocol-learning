# bToken

## methods

### initiallize

```solidity
/**
   * @dev Initializes the bToken
   * @param addressProvider The address of the address provider where this bToken will be used
   * @param treasury The address of the Bend treasury, receiving the fees on this bToken
   * @param underlyingAsset The address of the underlying asset of this bToken
   */
  function initialize(
    ILendPoolAddressesProvider addressProvider, // 存储各种地址的合约
    address treasury,   //  金库地址
    address underlyingAsset,    // 抵押资产地址
    uint8 bTokenDecimals,       // btoken 精度
    string calldata bTokenName, // btoken name
    string calldata bTokenSymbol    // btoken symbol
  ) external override initializer {
    __IncentivizedERC20_init(bTokenName, bTokenSymbol, bTokenDecimals);

    _treasury = treasury;
    _underlyingAsset = underlyingAsset;

    _addressProvider = addressProvider;

    emit Initialized(
      underlyingAsset,
      _addressProvider.getLendPool(),
      treasury,
      _addressProvider.getIncentivesController()
    );
  }
```

### mint

为抵押资产的用户发行 aToken，实际mint给用户的aToken数量需要经过缩放，只能被 `LendPool` 合约调用，用于管理额外的状态。该方法只能被 LendPool 合约调用。

```solidity
/**
   * @dev Mints `amount` bTokens to `user`
   * - Only callable by the LendPool, as extra state updates there need to be managed
   * @param user The address receiving the minted tokens
   * @param amount The amount of tokens getting minted
   * @param index The new liquidity index of the reserve
   * @return `true` if the the previous balance of the user was 0
   */
  function mint(
    address user,   // atoken 接受者
    uint256 amount, // 质押资产的真实数量
    uint256 index   // 缩放比例
  ) external override onlyLendPool returns (bool) {
    // 获取之前用户atoken余额
    uint256 previousBalance = super.balanceOf(user);

    // index is expressed in Ray, so:
    // amount.wadToRay().rayDiv(index).rayToWad() => amount.rayDiv(index)

    /* index 从池子创建以来 每单位liquidity累计的本息乘数因子
   * 假设总本金为 A, 年利率为 m , 复利计算方式, N 年后的总金额 TotalAmount(本金 + 利息总额) = A * (1+m)^N   
   * 这里 index => (1+m)^N , 上述公式就可以变为 TotalAmount = A * index
   * 其中 A 就表示为 aToken 的总量, TotalAmount 表示为对应的收益总量
   */

    /* amountScaled = amount / index
   * 假设 TotalAmount = A * index 
   * 现在假设 index 保持不变, ( TotalAmount + amount ) = ( A + X ) * index 要求其中X 的值  
   * 那么计算可得 X = amount / index
   */
    uint256 amountScaled = amount.rayDiv(index);
    require(amountScaled != 0, Errors.CT_INVALID_MINT_AMOUNT);
    // mint atoken
    _mint(user, amountScaled);

    emit Mint(user, amount, index);
    // 返回用户之前该抵押品的数量是否为0
    return previousBalance == 0;
  }
```

#### amount and amountScaled

- aToken 重载了 ERC20.balanceOf 方法，每次查询余额是包含了累计利息的数量
- 为了保证本金和累计利息的比例不变，这里要对 amount 进行缩放，实际 mint 的数量是 amountScaled
- 用户在t_current 时刻存入数量为amount资产 实际上就等价于 用户在t_0时刻（池子创建时）存入了数量为amountScaled的资产与在 t_0 -> t_current这段时间内复利产生的累计利息的本息和
- 即 `amount = amountScaled * index`，这里的 index 记录的就是 t_0 时刻到当前 t_current 时刻，流动性累计的本息乘数因子
- 比如池子创建时的年利率为百分之10，在池子创建一年后 此时的index为 (1+0.1）^1 = 1.1, alice存入amount为100$ETH，相当于alice在池子创建时就存入了amountScaled = 100 /（1+0.1）≈ 90.9$ETH经过一年的累计利息得到的本息和为amount = amountScaled * index = 90.9$ETH * (1+0.1)^1 = 99.99$ETH。 这两个值近似相等
- 为了统一计算，抹平不同抵押操作的时间和利率的不同，amountScaled 就是 aToken 实际记录的数量，由于全部缩放至 t_0时刻

### burn

销毁 aToken，转给user原资产，即 aToken 对应的抵押资产，销毁的aToken数量也需要缩放至t_0时刻（因为mint的时候实际mint的数量也是经过缩放t_0时刻的）。逻辑和 mint 一致。该方法只能被 LendPool 合约调用。

```solidity
/**
  * @dev Burns aTokens from `user` and sends the equivalent amount of underlying to `receiverOfUnderlying`
  * - Only callable by the LendingPool, as extra state updates there need to be managed
  * @param user The owner of the aTokens, getting them burned
  * @param receiverOfUnderlying The address that will receive the underlying
  * @param amount The amount being burned
  * @param index The new liquidity index of the reserve
  **/
function burn(
  address user, // 用户地址
  address receiverOfUnderlying, // 原资产地址
  uint256 amount, // 赎回数量
  uint256 index // reserve.liquidityIndex
) external override onlyLendingPool { // 只能被 LendingPool 调用
  uint256 amountScaled = amount.rayDiv(index);
  require(amountScaled != 0, Errors.CT_INVALID_BURN_AMOUNT);
  _burn(user, amountScaled);

  IERC20(_underlyingAsset).safeTransfer(receiverOfUnderlying, amount);

  emit Transfer(user, address(0), amount);
  emit Burn(user, receiverOfUnderlying, amount, index);
}
```

### balanceOf

重载了 ERC20.balanceOf 方法，返回的是债务本息总额 (本金 + 累计利息) 的数量，即用户查询 aToken 数量，总是包含了利息收益。

`NormalizedIncome` 是每单位流动性的累计的本息总额，注意这里需要用 amountScaled 计算，即缩放成 t_0 时刻的数量。

```solidity
/**
  * @dev Calculates the balance of the user: principal balance + interest generated by the principal
  * @param user The user whose balance is calculated
  * @return The balance of the user
  **/
function balanceOf(address user)
  public
  view
  override(IncentivizedERC20, IERC20)
  returns (uint256)
{
  // 计算过程基本在 `ReserveLogic.sol`中 具体代码在ReserveLogic.md中分析
  //===========计算 availableLiquidity 可借贷资产=========
  // availableLiquidity = availableLiquidity + liquidityAdded - liquidityTaken;

  // ============计算 borrow rate 借贷利率 ================
  // 去除了aave `reserve interest rate strategy`定息债务的概念，只保留了活息债务 因此不再有加权借贷利率的概念, 即：
  // borrow rate = currentVariableBorrowRate(活息债务利率)

  // =============计算 utilizationRate 流动性利用率（资金利用率)=========
  // utilizationRate = 总债务 / （availableLiquidity（可用流动性) + 总债务)


  // ============计算 current liquidity rate 存款利率=======
  // currentLiquidityRate = 债务利率 * u(资金利用率) * (1-金库预留) 即： 
  // currentLiquidityRate = borrowRate * utilizationRate * (1-金库预留)

  // ============计算cumulated liquidity interest 累计利息（复利）====
  // 累计本息 = （存款利率 + 1）^ 时间 ≈ 1 + time * 存款利率 （泰勒一次展开)
  // cumulatedLiquidityInterest = （1 + currentLiquidityRate）^ time = 1 + time * currentLiquidityRate）

  // =============计算liquidity index 流动性指数
  // 每次pool deposit/withdraw/repay/swapborrowratemode等等操作的时候,都会更新

  // liquidity index *= cumulatedLiquidityInterest

  // ===============计算NormalizedIncome==========================
  // NormalizedIncome = (年利率 * 时间间隔 / 一年的总时间（秒）+ 1) * liquidityIndex
  // 返回 amountScaled(BToken真实mint数量) * NormalizedIncome
  return super.balanceOf(user).rayMul(_pool.getReserveNormalizedIncome(_underlyingAsset));
}
```

---

btoken的设计完全遵循了aave v2 atoken的设计

参考链接：https://github.com/Dapp-Learning-DAO/Dapp-Learning/blob/main/defi/Aave/contract/3-AToken.md